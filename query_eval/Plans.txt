Before explain  using to avoid offset
SET track_io_timing = on;
SET jit = off;


Q1

SQL:

EXPLAIN (ANALYZE, BUFFERS, WAL, VERBOSE, SUMMARY, FORMAT JSON)
SELECT decade, tempo_class, COUNT(*) AS track_count
FROM tracks
GROUP BY decade, tempo_class
ORDER BY decade, tempo_class;

MONGODB:

db.tracks.aggregate([
  {
    $group: {
      _id: { decade: "$decade", tempo_class: "$tempo_class" },
      track_count: { $sum: 1 }
    }
  },
  { $sort: { "_id.decade": 1, "_id.tempo_class": 1 } }
]).explain("executionStats")


Q2

SQL:

EXPLAIN (ANALYZE, BUFFERS, WAL, VERBOSE, SUMMARY, FORMAT JSON)
SELECT
  a.id AS artist_id,
  a.name,
  AVG(af.valence) AS avg_valence,
  AVG(af.energy) AS avg_energy
FROM artists a
JOIN track_artists ta ON a.id = ta.artist_id
JOIN audio_features af ON ta.track_id = af.track_id
GROUP BY a.id, a.name
ORDER BY avg_valence DESC

MONGODB:

db.tracks.aggregate([
  { $unwind: "$id_artists" },
  { $group: {
      _id: "$id_artists",
      avg_valence: { $avg: "$audio_features.valence" },
      avg_energy: { $avg: "$audio_features.energy" }
  }},
  { $sort: { avg_valence: -1 } }
]).explain("executionStats")


Q3

SQL:

EXPLAIN (ANALYZE, BUFFERS, WAL, VERBOSE, SUMMARY, FORMAT JSON)
SELECT id, name, popularity, decade
FROM (
  SELECT *,
         ROW_NUMBER() OVER (PARTITION BY decade ORDER BY popularity DESC) AS rk
  FROM tracks
) ranked
WHERE rk <= 5;

MONGODB:

db.tracks.aggregate([
  { $sort: { decade: 1, popularity: -1 } },
  { $group: {
      _id: "$decade",
      top_tracks: { $push: {
        id: "$_id",
        name: "$name",
        popularity: "$popularity"
      }}
  }},
  { $project: {
      decade: "$_id",
      top_tracks: { $slice: ["$top_tracks", 5] }
  }}
]).explain("executionStats")


Q4

SQL:

EXPLAIN (ANALYZE, BUFFERS, WAL, VERBOSE, SUMMARY, FORMAT JSON)
SELECT decade, mood_cluster, COUNT(*) AS mood_count
FROM tracks
GROUP BY decade, mood_cluster
ORDER BY decade, mood_cluster;


MONGODB:

db.tracks.aggregate([
  { $group: {
      _id: { decade: "$decade", mood_cluster: "$mood_cluster" },
      mood_count: { $sum: 1 }
  }},
  { $sort: { "_id.decade": 1, "_id.mood_cluster": 1 } }
]).explain("executionStats")


Q5

SQL:

EXPLAIN (ANALYZE, BUFFERS, WAL, VERBOSE, SUMMARY, FORMAT JSON)
SELECT artist_id, COUNT(DISTINCT track_id) AS collab_count
FROM track_artists
GROUP BY artist_id
ORDER BY collab_count DESC


MONGODB:

db.tracks.aggregate([
  { $unwind: "$id_artists" },
  { $group: {
      _id: "$id_artists",
      collab_count: { $sum: 1 }
  }},
  { $sort: { collab_count: -1 } }
]).explain("executionStats")


IDX --------------------------------------------------



Q1

MONGODB:
db.tracks.aggregate(
  [
    { $sort: { decade: 1, tempo_class: 1 } },
    { $group: {
        _id: { decade: "$decade", tempo_class: "$tempo_class" },
        track_count: { $sum: 1 }
    }},
    { $sort: { "_id.decade": 1, "_id.tempo_class": 1 } }
  ],
  { hint: "decade_1_tempo_class_1", allowDiskUse: true }
).explain("executionStats")

SQL (PostgreSQL):
EXPLAIN (ANALYZE, BUFFERS, WAL, VERBOSE, SUMMARY, FORMAT JSON)
SELECT decade, tempo_class, COUNT(*) AS track_count
FROM tracks
GROUP BY decade, tempo_class
ORDER BY decade, tempo_class;



Q2  -- Artist popularity profile: avg & max popularity per artist

MONGODB:
db.tracks.aggregate(
  [
    { $project: {
        id_artists: 1,
        popularity: { $convert: { input: "$popularity", to: "double", onError: null, onNull: null } }
    }},
    { $match: { popularity: { $ne: null } }},
    { $unwind: "$id_artists" },
    { $group: {
        _id: "$id_artists",
        avg_popularity: { $avg: "$popularity" },
        max_popularity: { $max: "$popularity" },
        tracks: { $sum: 1 }
    }},
    { $sort: { avg_popularity: -1 } }
  ],
  { hint: "id_artists_1", allowDiskUse: true }
).explain("executionStats")

SQL (PostgreSQL):
EXPLAIN (ANALYZE, BUFFERS, WAL, VERBOSE, SUMMARY, FORMAT JSON)
SELECT
  ta.artist_id,
  AVG(t.popularity::double precision) AS avg_popularity,
  MAX(t.popularity::double precision) AS max_popularity,
  COUNT(*) AS tracks
FROM track_artists AS ta
JOIN tracks AS t ON t.id = ta.track_id
WHERE t.popularity IS NOT NULL
GROUP BY ta.artist_id
ORDER BY avg_popularity DESC;



Q3  -- Top-5 most popular tracks per decade

MONGODB:
db.tracks.aggregate(
  [
    { $sort: { decade: 1, popularity: -1 } },
    { $group: {
        _id: "$decade",
        top5: {
          $topN: {
            n: 5,
            sortBy: { popularity: -1 },
            output: { id: "$_id", name: "$name", popularity: "$popularity" }
          }
        }
    }},
    { $sort: { _id: 1 } }
  ],
  { hint: "decade_1_popularity_-1", allowDiskUse: true }
).explain("executionStats")

SQL (PostgreSQL):
EXPLAIN (ANALYZE, BUFFERS, WAL, VERBOSE, SUMMARY, FORMAT JSON)
SELECT id, name, popularity, decade
FROM (
  SELECT t.*,
         ROW_NUMBER() OVER (PARTITION BY t.decade ORDER BY t.popularity DESC) AS rk
  FROM tracks AS t
) ranked
WHERE rk <= 5
ORDER BY decade, popularity DESC;


Q4 — Decade × Popularity Bands (counts + avg energy/valence)

MONGODB:
db.tracks.aggregate(
  [
    { $match: { decade: { $ne: null }, popularity: { $ne: null } } },
    { $sort: { decade: 1, popularity: -1 } },
    { $set: {
        _p10: { $multiply: [ { $floor: { $divide: ["$popularity", 10] } }, 10 ] },
        energy_d: { $toDouble: "$energy" },
        valence_d: "$valence"
    }},
    { $set: {
        pop_bucket: {
          $concat: [
            { $toString: "$_p10" }, "-",
            { $toString: { $add: ["$_p10", 9] } }
          ]
        }
    }},
    { $group: {
        _id: { decade: "$decade", pop_bucket: "$pop_bucket" },
        track_count: { $sum: 1 },
        avg_energy:  { $avg: "$energy_d" },
        avg_valence: { $avg: "$valence_d" }
    }},
    { $sort: { "_id.decade": 1, "_id.pop_bucket": 1 } }
  ],
  { hint: "decade_1_popularity_-1", allowDiskUse: true }
).explain("executionStats")


SQL (PostgreSQL):
EXPLAIN (ANALYZE, BUFFERS, WAL, VERBOSE, SUMMARY, FORMAT JSON)
SELECT
  t.decade,
  CONCAT(
    (FLOOR(t.popularity/10.0)::int)*10, '-',
    (FLOOR(t.popularity/10.0)::int)*10 + 9
  ) AS pop_bucket,
  COUNT(*)                           AS track_count,
  AVG(af.energy)                     AS avg_energy,
  AVG(af.valence)                    AS avg_valence
FROM public.tracks AS t
LEFT JOIN public.audio_features AS af
  ON af.track_id = t.id
WHERE t.decade IS NOT NULL
  AND t.popularity IS NOT NULL
GROUP BY t.decade, pop_bucket
ORDER BY t.decade, pop_bucket;





Q5  -- Collaboration volume: tracks per artist (descending)

MONGODB:
db.tracks.aggregate(
  [
    { $project: { id_artists: 1 } },
    { $unwind: "$id_artists" },
    { $group: {
        _id: "$id_artists",
        collab_count: { $sum: 1 }
    }},
    { $sort: { collab_count: -1 } }
  ],
  { hint: "id_artists_1", allowDiskUse: true }
).explain("executionStats")

SQL (PostgreSQL):
EXPLAIN ANALYZE
SELECT artist_id, COUNT(DISTINCT track_id) AS collab_count
FROM track_artists
GROUP BY artist_id
ORDER BY collab_count DESC;



--------- UPDATE AND DELETE -------------------
U1

Bulk update on popularity


MONGODB


db.tracks.explain("executionStats").update(
  { decade: "1980s" },
  { $inc: { popularity: 5 } },
  { multi: true }
);

Bulk update and new col creation
SQL

EXPLAIN (ANALYZE, BUFFERS, WAL, VERBOSE, SUMMARY, FORMAT JSON)
UPDATE public.tracks
SET popularity = LEAST(popularity + 5, 100)
WHERE decade = '1980s';


D1 
bulk delete on tempo_class


SQL

EXPLAIN (ANALYZE, BUFFERS, WAL, VERBOSE, SUMMARY, FORMAT JSON)
DELETE FROM public.tracks
WHERE tempo_class = 'fast';

MONGODB

db.runCommand({
  explain: {
    delete: "tracks",
    deletes: [
      { q: { tempo_class: "fast" }, limit: 0 }  // 0 = delete ALL matches
    ]
  },
  verbosity: "executionStats"
});



